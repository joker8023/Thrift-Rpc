#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def master_checklist(self, device_uuid, access_token, mic, symbol):
        """
        Parameters:
         - device_uuid
         - access_token
         - mic
         - symbol
        """
        pass

    def ratings(self, device_uuid, access_token, mic, symbol):
        """
        Parameters:
         - device_uuid
         - access_token
         - mic
         - symbol
        """
        pass

    def top33(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        pass

    def near_pivot(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        pass

    def volume_up(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        pass

    def dividend_stocks(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        pass

    def registered(self, won_key, device_uuid, timestamp, access_token):
        """
        Parameters:
         - won_key
         - device_uuid
         - timestamp
         - access_token
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def master_checklist(self, device_uuid, access_token, mic, symbol):
        """
        Parameters:
         - device_uuid
         - access_token
         - mic
         - symbol
        """
        self.send_master_checklist(device_uuid, access_token, mic, symbol)
        return self.recv_master_checklist()

    def send_master_checklist(self, device_uuid, access_token, mic, symbol):
        self._oprot.writeMessageBegin('master_checklist', TMessageType.CALL, self._seqid)
        args = master_checklist_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.mic = mic
        args.symbol = symbol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_master_checklist(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = master_checklist_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "master_checklist failed: unknown result")

    def ratings(self, device_uuid, access_token, mic, symbol):
        """
        Parameters:
         - device_uuid
         - access_token
         - mic
         - symbol
        """
        self.send_ratings(device_uuid, access_token, mic, symbol)
        return self.recv_ratings()

    def send_ratings(self, device_uuid, access_token, mic, symbol):
        self._oprot.writeMessageBegin('ratings', TMessageType.CALL, self._seqid)
        args = ratings_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.mic = mic
        args.symbol = symbol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ratings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ratings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ratings failed: unknown result")

    def top33(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        self.send_top33(device_uuid, access_token)
        return self.recv_top33()

    def send_top33(self, device_uuid, access_token):
        self._oprot.writeMessageBegin('top33', TMessageType.CALL, self._seqid)
        args = top33_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_top33(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = top33_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "top33 failed: unknown result")

    def near_pivot(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        self.send_near_pivot(device_uuid, access_token)
        return self.recv_near_pivot()

    def send_near_pivot(self, device_uuid, access_token):
        self._oprot.writeMessageBegin('near_pivot', TMessageType.CALL, self._seqid)
        args = near_pivot_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_near_pivot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = near_pivot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "near_pivot failed: unknown result")

    def volume_up(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        self.send_volume_up(device_uuid, access_token)
        return self.recv_volume_up()

    def send_volume_up(self, device_uuid, access_token):
        self._oprot.writeMessageBegin('volume_up', TMessageType.CALL, self._seqid)
        args = volume_up_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_volume_up(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = volume_up_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "volume_up failed: unknown result")

    def dividend_stocks(self, device_uuid, access_token):
        """
        Parameters:
         - device_uuid
         - access_token
        """
        self.send_dividend_stocks(device_uuid, access_token)
        return self.recv_dividend_stocks()

    def send_dividend_stocks(self, device_uuid, access_token):
        self._oprot.writeMessageBegin('dividend_stocks', TMessageType.CALL, self._seqid)
        args = dividend_stocks_args()
        args.device_uuid = device_uuid
        args.access_token = access_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dividend_stocks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dividend_stocks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dividend_stocks failed: unknown result")

    def registered(self, won_key, device_uuid, timestamp, access_token):
        """
        Parameters:
         - won_key
         - device_uuid
         - timestamp
         - access_token
        """
        self.send_registered(won_key, device_uuid, timestamp, access_token)
        return self.recv_registered()

    def send_registered(self, won_key, device_uuid, timestamp, access_token):
        self._oprot.writeMessageBegin('registered', TMessageType.CALL, self._seqid)
        args = registered_args()
        args.won_key = won_key
        args.device_uuid = device_uuid
        args.timestamp = timestamp
        args.access_token = access_token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_registered(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = registered_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "registered failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["master_checklist"] = Processor.process_master_checklist
        self._processMap["ratings"] = Processor.process_ratings
        self._processMap["top33"] = Processor.process_top33
        self._processMap["near_pivot"] = Processor.process_near_pivot
        self._processMap["volume_up"] = Processor.process_volume_up
        self._processMap["dividend_stocks"] = Processor.process_dividend_stocks
        self._processMap["registered"] = Processor.process_registered

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_master_checklist(self, seqid, iprot, oprot):
        args = master_checklist_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = master_checklist_result()
        try:
            result.success = self._handler.master_checklist(args.device_uuid, args.access_token, args.mic, args.symbol)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("master_checklist", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ratings(self, seqid, iprot, oprot):
        args = ratings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ratings_result()
        try:
            result.success = self._handler.ratings(args.device_uuid, args.access_token, args.mic, args.symbol)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ratings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_top33(self, seqid, iprot, oprot):
        args = top33_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = top33_result()
        try:
            result.success = self._handler.top33(args.device_uuid, args.access_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("top33", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_near_pivot(self, seqid, iprot, oprot):
        args = near_pivot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = near_pivot_result()
        try:
            result.success = self._handler.near_pivot(args.device_uuid, args.access_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("near_pivot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_volume_up(self, seqid, iprot, oprot):
        args = volume_up_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = volume_up_result()
        try:
            result.success = self._handler.volume_up(args.device_uuid, args.access_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("volume_up", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dividend_stocks(self, seqid, iprot, oprot):
        args = dividend_stocks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dividend_stocks_result()
        try:
            result.success = self._handler.dividend_stocks(args.device_uuid, args.access_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dividend_stocks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_registered(self, seqid, iprot, oprot):
        args = registered_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registered_result()
        try:
            result.success = self._handler.registered(args.won_key, args.device_uuid, args.timestamp, args.access_token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("registered", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class master_checklist_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
     - mic
     - symbol
    """


    def __init__(self, device_uuid=None, access_token=None, mic=None, symbol=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token
        self.mic = mic
        self.symbol = symbol

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('master_checklist_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        if self.mic is not None:
            oprot.writeFieldBegin('mic', TType.STRING, 3)
            oprot.writeString(self.mic.encode('utf-8') if sys.version_info[0] == 2 else self.mic)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 4)
            oprot.writeString(self.symbol.encode('utf-8') if sys.version_info[0] == 2 else self.symbol)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(master_checklist_args)
master_checklist_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mic', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'symbol', 'UTF8', None, ),  # 4
)


class master_checklist_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MasterCheckModel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('master_checklist_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(master_checklist_result)
master_checklist_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MasterCheckModel, None], None, ),  # 0
)


class ratings_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
     - mic
     - symbol
    """


    def __init__(self, device_uuid=None, access_token=None, mic=None, symbol=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token
        self.mic = mic
        self.symbol = symbol

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ratings_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        if self.mic is not None:
            oprot.writeFieldBegin('mic', TType.STRING, 3)
            oprot.writeString(self.mic.encode('utf-8') if sys.version_info[0] == 2 else self.mic)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 4)
            oprot.writeString(self.symbol.encode('utf-8') if sys.version_info[0] == 2 else self.symbol)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ratings_args)
ratings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mic', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'symbol', 'UTF8', None, ),  # 4
)


class ratings_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RatingsModel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ratings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ratings_result)
ratings_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RatingsModel, None], None, ),  # 0
)


class top33_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
    """


    def __init__(self, device_uuid=None, access_token=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('top33_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(top33_args)
top33_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
)


class top33_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Top33Model()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('top33_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(top33_result)
top33_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Top33Model, None], None, ),  # 0
)


class near_pivot_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
    """


    def __init__(self, device_uuid=None, access_token=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('near_pivot_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(near_pivot_args)
near_pivot_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
)


class near_pivot_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StockListModel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('near_pivot_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(near_pivot_result)
near_pivot_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StockListModel, None], None, ),  # 0
)


class volume_up_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
    """


    def __init__(self, device_uuid=None, access_token=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('volume_up_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(volume_up_args)
volume_up_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
)


class volume_up_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StockListModel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('volume_up_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(volume_up_result)
volume_up_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StockListModel, None], None, ),  # 0
)


class dividend_stocks_args(object):
    """
    Attributes:
     - device_uuid
     - access_token
    """


    def __init__(self, device_uuid=None, access_token=None,):
        self.device_uuid = device_uuid
        self.access_token = access_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dividend_stocks_args')
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 1)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 2)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dividend_stocks_args)
dividend_stocks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'access_token', 'UTF8', None, ),  # 2
)


class dividend_stocks_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StockListModel()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dividend_stocks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dividend_stocks_result)
dividend_stocks_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StockListModel, None], None, ),  # 0
)


class registered_args(object):
    """
    Attributes:
     - won_key
     - device_uuid
     - timestamp
     - access_token
    """


    def __init__(self, won_key=None, device_uuid=None, timestamp=None, access_token=None,):
        self.won_key = won_key
        self.device_uuid = device_uuid
        self.timestamp = timestamp
        self.access_token = access_token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.won_key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.device_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.access_token = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registered_args')
        if self.won_key is not None:
            oprot.writeFieldBegin('won_key', TType.STRING, 1)
            oprot.writeString(self.won_key.encode('utf-8') if sys.version_info[0] == 2 else self.won_key)
            oprot.writeFieldEnd()
        if self.device_uuid is not None:
            oprot.writeFieldBegin('device_uuid', TType.STRING, 2)
            oprot.writeString(self.device_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.device_uuid)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        if self.access_token is not None:
            oprot.writeFieldBegin('access_token', TType.STRING, 4)
            oprot.writeString(self.access_token.encode('utf-8') if sys.version_info[0] == 2 else self.access_token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registered_args)
registered_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'won_key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'device_uuid', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'access_token', 'UTF8', None, ),  # 4
)


class registered_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registered_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registered_result)
registered_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

